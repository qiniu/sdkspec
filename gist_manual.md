# Gist 编写说明
## 功能说明
> 在程序编写的过程中经常会遇到文档展示代码和实际不一致的情况，主要是文档方面的更新没有驱动因素，导致往往文档要落后于代码。  

为了解决这个问题，需要在代码更新的同时确保文档的有效性，所以Gist工具需要<u>**在以下环境才能发挥作用**</u>：

 1. 文档使用的代码范例需要从代码文件中提取，代码文件可以是单元测试，demo程序，或者单单是针对Gist而编写的示范代码。
 2. 在代码更新的时候，上诉的代码文件需要检验有效性，静态语言可以通过编译来确保类似函数接口是否更改等问题被检测到，动态语言（JIT编译）需要单独编写单元测试来确保。
 3. 如果第二步执行失败应该和代码单元测试错误同样对待。

## 使用方式
（假设使用的文档格式为md）

1. 人工编写的包含引用gist片段的文件名一般以gist.md结尾。通过gist工具生成后缀名为.md的文件，两者都应该上传到仓库，并且每次修改都应该修改gist.md而不是直接修改.md
2. 和gist.md同目录存在的可以是包含需要引用到代码文件，gist.md中引用的文件还可以是实际代码文件，单元测试，在文件中需要通过注释(约定的格式)来分割代码片段并命名，在gist.md中可以通过相对路径来定位他们并取得目标片段。
3. 将代码文件的 `编译/单元测试运行` 加入.travis.yml, 如果失败应该通过 strerr 输出，确保 travis-ci 令其不通过。

> 此方案并不完美，暂时没有找到可以自动生成/更新的方法，应该可以在git或者github加hook做文章

## 支持文件类型
gist并不会根据文件后缀名来判断类型，但是他会以几种主流的注释方式来尝试获取代码的片段划分信息
```
// @gist anchor
# @gist anchor
/* @gist anchor */
<!-- @gist anchor -->
```
所以不用在支持多种注释风格的语言里拘泥于该使用哪种注释方式，当然也可以使用语言不支持的的注释风格(如果编译能通过的话 :))

## 标记语法

开始

	@gist <anchor>

结束

	@endgist

`<anchor>` 表示片段名, 如果同个文件中存在多个 `<anchor>`， 将会合并成一个，以 `\n...\n` 分隔
`<anchor>` 的命名规则是 `[\w\-_]+`

## 引用语法

引用文件里面的一个片段

	@gist(relative/path/to/file#anthor)

引用一整个文件

	@gist(relative/path/to/file)

> 相对路径的基准是gist.md所在的目录

## 使用方式
gist不会修改文件，只是将转化后的文本通过 stdout 输出，如果发现引用文件(片段)不存在，将会通过 stderr 输出错误信息。  
直接制定gist.md文件即可

	gist.py README.gist.md

## 注意事项
生成的文档将无视原来的缩进层级，但是片段内部的缩进层级会保留。并且每行引入的代码会加入引用代码所在的相同的缩进层级。